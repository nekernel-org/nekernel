\documentclass{article}
\usepackage{graphicx}
\usepackage{hyperref}

\title{BinaryMutex: Technical Documentation}
\author{Amlal El Mahrouss}
\date{\today}

\begin{document}

\maketitle

\section{Abstract}

{The BinaryMutex is a core component of NeKernel (NeKernel/VMKernel) based systems. The pattern excludes other acquirers to own the USER\_PROCESS that is currently being hold. Thus the acquiree is the USER\_PROCESS itself}

\section{Overview}

{The BinaryMutex comes from the need to make sure that no race conditions occurs in kernel code. Most of those race conditions happens in process handling code. Thus the design of the BinaryMutex (which holds a process handle to it)}

\begin{verbatim}
BinaryMutex mux;
mux.Lock(process);

// Say we want to interact with the process itself on this thread, 
we can then make sure that no race condition happens by using:
constexpr auto kSecondsMax = 5;
while (mux.WaitForProcess(kSecondsMax));

// finally do our task now.

process.DoFoo();
\end{verbatim}

\section{Implementation}

The source implementation consists of this simple C++ class:

\begin{verbatim}
class BinaryMutex final {
 public:
  explicit BinaryMutex() = default;
  ~BinaryMutex()         = default;

 public:
  bool IsLocked() const;
  bool Unlock() noexcept;

 public:
  BOOL WaitForProcess(const UInt32& sec) noexcept;

 public:
  bool Lock(USER_PROCESS* process);
  bool LockOrWait(USER_PROCESS* process, TimerInterface* timer);

 public:
  NE_COPY_DEFAULT(BinaryMutex)

 private:
  USER_PROCESS* fLockingProcess;
};
\end{verbatim}

\section{Conclusion}

{This design pattern is useful for systems that need to make sure that a process isn't tampered by concurrent usages.
Thus its existence in VMKernel and NeKernel.}

\section{References}

{NeKernel}: \href{https://github.com/nekernel-org/nekernel}{NeKernel}

{VMKernel}: \href{https://snu.systems/specs/vmkernel}{VMKernel}

{BinaryMutex}: \href{https://github.com/nekernel-org/nekernel/blob/dev/dev/kernel/KernelKit/BinaryMutex.h}{BinaryMutex}

\end{document}
